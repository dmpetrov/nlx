from typing import Any, Dict, List, Optional, Type, TypeVar, Union

from pydantic import Field, validator

from dvc.types import OptStr, SingleOrListOf

from .base import BaseModel


class OutProps(BaseModel):
    cache: bool = Field(True, description="Cache output by DVC")
    persist: bool = Field(False, description="Persist output between runs")
    checkpoint: bool = Field(
        False,
        description="Indicate that the output is associated with "
        "in-code checkpoints",
    )
    desc: Optional[str] = Field(
        None,
        description="User description for the output",
        title="Description",
    )


class MetricProps(OutProps):
    pass


FilePath = str


class PlotProps(OutProps):
    template: Optional[FilePath] = Field(
        None, description="Default plot template"
    )
    x: OptStr = Field(
        None, description="Default field name to use as x-axis data"
    )
    y: OptStr = Field(
        None, description="Default field name to use as y-axis data"
    )
    x_label: OptStr = Field(None, description="Default label for the x-axis")
    y_label: OptStr = Field(None, description="Default label for the y-axis")
    title: OptStr = Field(None, description="Default plot title")
    header: bool = Field(
        False, description="Whether the target CSV or TSV has a header or not"
    )


class LiveProps(PlotProps):
    summary: bool = Field(
        True, description="Signals dvclive to dump latest metrics file"
    )
    html: bool = Field(
        True, description="Signals dvclive to produce training report"
    )


# eg: "file.txt", "file.txt:foo,bar", "file.txt:foo"
VarImportSpec = str  # validate here?
# {"foo" (str) : "foobar" (Any) }
LocalVarKey = str
LocalVarValue = Any
VarsSpec = List[Union[VarImportSpec, Dict[LocalVarKey, LocalVarValue]]]

# key name of the param, usually from `params.yaml`
ParamKey = str
ParamsSpec = List[Union[ParamKey, Dict[FilePath, List[ParamKey]]]]

_Entry = TypeVar("_Entry", covariant=True)
_Flag = TypeVar("_Flag", covariant=True)
EntryWithOptFlags = Union[Dict[_Entry, _Flag], _Entry]


class WithDescription(BaseModel):
    desc: OptStr = Field(
        None, description="Description of the stage", title="Description"
    )


class StageDefinition(WithDescription, BaseModel):
    """This is the raw one, which could be parametrized."""

    cmd: SingleOrListOf[str] = Field(
        ..., description="Command to run", title="Command(s)"
    )  # required
    wdir: OptStr = Field(
        None, description="Working directory", title="Working Directory"
    )
    deps: List[FilePath] = Field(
        default_factory=list,
        description="Dependencies for the stage",
        title="Dependencies",
    )
    params: ParamsSpec = Field(
        default_factory=list,
        description="Params for the stage",
        title="Parameter Dependencies",
    )
    vars: VarsSpec = Field(
        default_factory=list,
        description="Variables for the stage",
        title="Variables",
    )
    frozen: bool = Field(False, description="Assume stage as unchanged")
    meta: Any = Field(
        None, description="Additional information/metadata", title="Metadata"
    )
    always_changed: bool = Field(
        False, description="Assume stage as always changed"
    )
    outs: List[EntryWithOptFlags[FilePath, OutProps]] = Field(
        default_factory=list,
        description="Additional information/metadata",
        title="Outputs",
    )
    plots: List[
        EntryWithOptFlags[FilePath, SingleOrListOf[PlotProps]]
    ] = Field(
        default_factory=list, description="Plots of the stage", title="Plots"
    )
    metrics: List[EntryWithOptFlags[FilePath, MetricProps]] = Field(
        default_factory=list,
        description="Metrics of the stage",
        title="Metrics",
    )
    live: EntryWithOptFlags[FilePath, LiveProps] = Field(
        default_factory=list,
        description="Declare output as dvclive",
        title="Dvclive",
    )

    # Note: we don't support parametrization in props and in
    # frozen/always_changed/meta yet.


# trying to differentiate here between normal str expectation
# and parametrized ones
ParametrizedString = str  # validate with constr()?

ListAny = List[Any]
DictStrAny = Dict[str, Any]

FOREACH_DESC = """\
Iterable to loop through in foreach. Can be a parametrized string, list \
or a dictionary.

The stages will be generated by iterating through this data, by substituting
data in the `do` block."""

DO_DESC = """\
Parametrized stage definition that'll be substituted over for each of the
value from the foreach data."""


class ForeachDo(BaseModel):
    foreach: Union[ParametrizedString, ListAny, DictStrAny] = Field(
        ..., description=FOREACH_DESC
    )
    do: StageDefinition = Field(..., description=DO_DESC)


Definition = Union[ForeachDo, StageDefinition]
StageName = str


class Schema(BaseModel):
    vars: VarsSpec = Field(
        default_factory=list,
        description="Variables for the parametrization",
        title="Variables",
    )
    stages: Dict[StageName, Definition] = Field(
        default_factory=dict, description="List of stages"
    )

    @validator("stages", each_item=True, pre=True)
    @classmethod
    def validate_stages(cls, v: Any):
        if not isinstance(v, dict):
            raise TypeError("must be a dict")

        if v.keys() & {"foreach", "do"}:
            return ForeachDo.parse_obj(v)

        return StageDefinition.parse_obj(v)

    class Config:
        title = "dvc.yaml schema"


def get_schema(extra: str = "forbid") -> Type[Schema]:
    assert extra
    return Schema
